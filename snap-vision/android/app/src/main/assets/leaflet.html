<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Leaflet Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <style>
    html, body, #map {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    .leaflet-popup-content-wrapper {
      font-size: 14px;
    }
    .poi-marker {
      background-color: #007bff;
      border: 2px solid white;
      border-radius: 50%;
      width: 12px;
      height: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .poi-marker:hover {
      background-color: #0056b3;
      transform: scale(1.2);
      cursor: pointer;
    }
    .poi-label {
      background-color: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
      font-weight: bold;
      color: #333;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      pointer-events: none;
    }
    .pulse {
      border-radius: 50%;
      box-shadow: 0 0 0 rgba(0, 120, 255, 0.4);
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(0, 120, 255, 0.4);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(0, 120, 255, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(0, 120, 255, 0);
      }
    }
    .route-progress {
      stroke-dasharray: 6;
      animation: dash 1.5s linear infinite;
    }
    @keyframes dash {
      to {
        stroke-dashoffset: 12;
      }
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script>
    // Global variables
    let map;
    let userMarker = null;
    let userIcon = null;
    let crowdMarker = null;
    let destinationMarker = null;
    let endCircle = null;
    let startCircle = null;
    let poiMarkers = [];
    let poiData = [];
    let route = null;
    let progressLine = null;
    let isNavigating = false;
    let userCoordinates = null;

    // Reported crowd densities and corresponding emoji/icons
    const crowdEmojis = {
      empty: 'üü¢ Empty',
      light: 'üü° Light',
      moderate: 'üü† Moderate',
      crowded: 'üî¥ Crowded',
      overcrowded: '‚ö´ Overcrowded'
    };

    // Transport mode icons
    const transportIcons = {
      walking: 'üö∂',
      cycling: 'üö≤',
      driving: 'üöó'
    };

    // Handle uncaught errors
    window.onerror = function(message, source, lineno, colno, error) {
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'ERROR',
          message,
          source,
          line: lineno,
          column: colno,
          stack: error?.stack
        }));
      }
    };

    function initMap() {
      map = L.map('map', {
        zoomControl: true,
        attributionControl: true,
        preferCanvas: true,
        center: [-25.7557, 28.2314],
        zoom: 14,
      });

      L.tileLayer('https://api.maptiler.com/maps/basic-v2/{z}/{x}/{y}.png?key=xUUmaj1CwbUxWTcxxbmb', {
        attribution: '¬© OpenStreetMap contributors & MapTiler',
        tileSize: 512,
        zoomOffset: -1,
        detectRetina: true,
        crossOrigin: 'anonymous'
      }).addTo(map);

      // Create custom icon for user location
      userIcon = L.divIcon({
        className: 'user-location-icon',
        html: '<div style="background-color: #007bff; border: 3px solid white; border-radius: 50%; width: 16px; height: 16px; box-shadow: 0 2px 5px rgba(0,0,0,0.5);" class="pulse"></div>',
        iconSize: [22, 22],
        iconAnchor: [11, 11]
      });

      // Tell React Native that the map is ready
      setTimeout(() => {
        map.invalidateSize();
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage('MAP_READY');
        }
      }, 500);
    }

    // Function to update user location
    window.updateUserLocation = function(lat, lng) {
      // Store these coordinates for later use
      userCoordinates = { lat, lng };
      
      if (!map) return;

      const coords = [lat, lng];

      if (userMarker) {
        userMarker.setLatLng(coords);
      } else {
        userMarker = L.marker(coords, {
          icon: userIcon,
          zIndexOffset: 1000 // Ensure user marker is on top
        }).addTo(map);
      }

      // Only center map on user if not navigating
      if (!isNavigating) {
        map.setView(coords, map.getZoom() || 16);
      }
    };

    // Function to show crowd report above the location
    window.updateCrowdDensity = function(lat, lon, density) {
      const coords = [lat, lon];
      if (!map) return;

      const label = crowdEmojis[density] || density;

      if (crowdMarker) {
        crowdMarker.setLatLng(coords).setPopupContent(`üë• Crowd: ${label}`).openPopup();
      } else {
        crowdMarker = L.marker(coords)
          .addTo(map)
          .bindPopup(`üë• Crowd: ${label}`)
          .openPopup();
      }
    };

    // Function to display POIs on the map
    window.displayPOIs = function(pois) {
      if (!map || !Array.isArray(pois)) return;
      
      console.log("üè¢ Displaying", pois.length, "POIs on map");
      
      // Clear existing POI markers
      poiMarkers.forEach(marker => map.removeLayer(marker));
      poiMarkers = [];
      poiData = pois;

      pois.forEach(poi => {
        if (!poi.centroid || !poi.centroid.latitude || !poi.centroid.longitude) {
          console.warn("‚ö†Ô∏è POI missing coordinates:", poi);
          return;
        }

        const coords = [poi.centroid.latitude, poi.centroid.longitude];
        
        // Create custom icon for POI
        const poiIcon = L.divIcon({
          className: 'poi-marker',
          html: '',
          iconSize: [12, 12],
          iconAnchor: [6, 6]
        });

        // Create marker
        const marker = L.marker(coords, { icon: poiIcon })
          .addTo(map)
          .bindPopup(`
            <div style="text-align: center;">
              <strong>üè¢ ${poi.name || 'Unnamed Building'}</strong><br>
              <button onclick="selectPOI('${poi.id}')" style="
                margin-top: 8px;
                padding: 6px 12px;
                background-color: #007bff;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
              ">Navigate Here</button>
            </div>
          `);

        // Add label that shows on hover or zoom
        if (map.getZoom() >= 16) {
          const label = L.marker(coords, {
            icon: L.divIcon({
              className: 'poi-label',
              html: poi.name || 'Building',
              iconSize: [null, null],
              iconAnchor: [0, 0]
            })
          }).addTo(map);
          
          poiMarkers.push(label);
        }

        poiMarkers.push(marker);
      });

      // Show/hide labels based on zoom level
      map.on('zoomend', function() {
        const zoom = map.getZoom();
        poiMarkers.forEach(marker => {
          if (marker.options.icon && marker.options.icon.options.className === 'poi-label') {
            if (zoom >= 16) {
              marker.addTo(map);
            } else {
              map.removeLayer(marker);
            }
          }
        });
      });
    };

    // Function to handle POI selection from map
    window.selectPOI = function(poiId) {
      const poi = poiData.find(p => p.id === poiId);
      if (poi && window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'POI_SELECTED',
          poi: poi
        }));
      }
    };

    // Function to clear the destination marker and end circle
    window.clearDestinationMarker = function() {
      if (destinationMarker) {
        map.removeLayer(destinationMarker);
        destinationMarker = null;
      }
      if (endCircle) {
        map.removeLayer(endCircle);
        endCircle = null;
      }
    };

    // Function to draw a route between points
    window.drawRoute = function(coords, transportMode = 'walking') {
      if (!map || !Array.isArray(coords) || coords.length < 2) return;
      
      // Set navigation flag
      isNavigating = true;
      
      // Remove existing route if already present
      if (route) {
        map.removeLayer(route);
        route = null;
      }
      
      if (progressLine) {
        map.removeLayer(progressLine);
        progressLine = null;
      }
    
      // Remove previous destination marker
      if (destinationMarker) {
        map.removeLayer(destinationMarker);
        destinationMarker = null;
      }
    
      // Remove previous end circle
      if (endCircle) {
        map.removeLayer(endCircle);
        endCircle = null;
      }
    
      // Remove previous start circle
      if (startCircle) {
        map.removeLayer(startCircle);
        startCircle = null;
      }
      
      // Convert coordinates to Leaflet format
      let latlngs = coords.map(([lon, lat]) => [lat, lon]);
      
      // If we have the user's exact coordinates, use them for the start point
      if (userCoordinates && latlngs.length > 0) {
        latlngs[0] = [userCoordinates.lat, userCoordinates.lng];
      }
      
      // Choose color based on transport mode
      let routeColor;
      switch (transportMode) {
        case 'cycling':
          routeColor = '#1E88E5'; // Blue
          break;
        case 'driving':
          routeColor = '#7B1FA2'; // Purple
          break;
        case 'walking':
        default:
          routeColor = '#43A047'; // Green
          break;
      }
      
      // Create the route polyline
      route = L.polyline(latlngs, {
        color: routeColor,
        weight: 5,
        opacity: 0.8,
        lineCap: 'round',
        lineJoin: 'round'
      }).addTo(map);
      
      // Get transport icon
      const transportIcon = transportIcons[transportMode] || 'üö∂';
    
      // Add start point indicator (don't use a separate marker, just highlight route start)
      startCircle = L.circle(latlngs[0], { 
        radius: 8, 
        color: routeColor,
        fillColor: '#fff',
        fillOpacity: 1,
        weight: 3
      }).addTo(map);
    
      // Add end marker with transport icon
      const endPoint = latlngs[latlngs.length - 1];
      destinationMarker = L.marker(endPoint).addTo(map)
        .bindPopup(`${transportIcon} Destination`)
        .openPopup();
        
      // Add end circle
      endCircle = L.circle(endPoint, { 
        radius: 8, 
        color: '#D32F2F', 
        fillColor: '#fff',
        fillOpacity: 1,
        weight: 3
      }).addTo(map);
    
      // Fit map to show the whole route with padding
      const bounds = route.getBounds();
      map.fitBounds(bounds.pad(0.2));
    };
    
    // Function to draw an alternative route
    window.drawAlternativeRoute = function(coords, alternativeIndex) {
      if (!map || !Array.isArray(coords) || coords.length < 2) return;
      
      // Convert coordinates to Leaflet format
      const latlngs = coords.map(([lon, lat]) => [lat, lon]);
      
      // Create the alternative route with dashed line and reduced opacity
      const alternativeRoute = L.polyline(latlngs, {
        color: '#9E9E9E', // Gray color for alternatives
        weight: 4,
        opacity: 0.6,
        dashArray: '6,8',
        lineCap: 'round',
        lineJoin: 'round'
      }).addTo(map);
      
      // Add event handlers to make this route the primary route when clicked
      alternativeRoute.on('click', function() {
        // Replace the primary route with this one
        if (route) {
          map.removeLayer(route);
        }
        
        // Remove the dashed style and update color
        alternativeRoute.setStyle({
          color: '#43A047',
          dashArray: null,
          opacity: 0.8
        });
        
        // Update the global route variable to this one
        route = alternativeRoute;
        
        // Notify React Native that the route was changed
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(JSON.stringify({
            type: 'ROUTE_CHANGED',
            alternativeIndex: alternativeIndex
          }));
        }
      });
      
      return alternativeRoute;
    };

    // Update route progress
    window.updateRouteProgress = function(pointIndex) {
      if (!route) return;
      
      // Get the route points
      const routePoints = route.getLatLngs();
      
      // Ensure pointIndex is valid
      if (pointIndex < 0 || pointIndex >= routePoints.length) return;
      
      // Highlight the completed portion of the route
      const completedSegment = routePoints.slice(0, pointIndex + 1);
      
      if (!progressLine) {
        progressLine = L.polyline(completedSegment, {
          color: '#FFC107', // Amber color for progress
          weight: 7,
          opacity: 0.9,
          className: 'route-progress'
        }).addTo(map);
      } else {
        progressLine.setLatLngs(completedSegment);
      }
    };
    
    // Update the route with new coordinates
    window.updateRoute = function(coordinates) {
      // Just use drawRoute with updated coordinates
      window.drawRoute(coordinates);
    };
    
    // Clear the route
    window.clearRoute = function() {
      isNavigating = false;
      
      if (route) {
        map.removeLayer(route);
        route = null;
      }
      
      if (progressLine) {
        map.removeLayer(progressLine);
        progressLine = null;
      }
      
      if (startCircle) {
        map.removeLayer(startCircle);
        startCircle = null;
      }
      
      if (endCircle) {
        map.removeLayer(endCircle);
        endCircle = null;
      }
      
      if (destinationMarker) {
        map.removeLayer(destinationMarker);
        destinationMarker = null;
      }
    };

    // Start the map
    try {
      initMap();
    } catch (e) {
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'ERROR',
          message: e.message,
          stack: e.stack
        }));
      }
    }
  </script>
</body>
</html>