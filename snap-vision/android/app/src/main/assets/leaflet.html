<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Leaflet Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
  <style>
    html, body, #map {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    .leaflet-popup-content-wrapper {
      font-size: 14px;
    }
    .poi-marker {
      background-color: #007bff;
      border: 2px solid white;
      border-radius: 50%;
      width: 12px;
      height: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .poi-marker:hover {
      background-color: #0056b3;
      transform: scale(1.2);
      cursor: pointer;
    }
    .poi-label {
      background-color: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
      font-weight: bold;
      color: #333;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
  <script>
    let map;
    let userMarker = null;
    let crowdMarker = null;
    let destinationMarker = null;
    let endCircle = null;
    let startCircle = null;
    let poiMarkers = [];
    let poiData = [];

    // Reported crowd densities and corresponding emoji/icons
    const crowdEmojis = {
      empty: 'üü¢ Empty',
      light: 'üü° Light',
      moderate: 'üü† Moderate',
      crowded: 'üî¥ Crowded',
      overcrowded: '‚ö´ Overcrowded'
    };

    // Handle uncaught errors
    window.onerror = function(message, source, lineno, colno, error) {
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'ERROR',
          message,
          source,
          line: lineno,
          column: colno,
          stack: error?.stack
        }));
      }
    };

    function initMap() {
      map = L.map('map', {
        zoomControl: true,
        attributionControl: true,
        preferCanvas: true,
        center: [-25.7557, 28.2314],
        zoom: 14,
      });

      L.tileLayer('https://api.maptiler.com/maps/basic-v2/{z}/{x}/{y}.png?key=xUUmaj1CwbUxWTcxxbmb', {
        attribution: '¬© OpenStreetMap contributors & MapTiler',
        tileSize: 512,
        zoomOffset: -1,
        detectRetina: true,
        crossOrigin: 'anonymous'
      }).addTo(map);

      // Tell React Native that the map is ready
      setTimeout(() => {
        map.invalidateSize();
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage('MAP_READY');
        }
      }, 500);
    }

    // Function to update user location
    window.updateUserLocation = function(lat, lon) {
      const coords = [lat, lon];
      if (!map) return;

      map.setView(coords, 16);

      if (userMarker) {
        userMarker.setLatLng(coords);
      } else {
        userMarker = L.marker(coords)
          .addTo(map)
          .bindPopup("üìç You are here!")
          .openPopup();
      }
    };

    // Function to show crowd report above the location
    window.updateCrowdDensity = function(lat, lon, density) {
      const coords = [lat, lon];
      if (!map) return;

      const label = crowdEmojis[density] || density;

      if (crowdMarker) {
        crowdMarker.setLatLng(coords).setPopupContent(`üë• Crowd: ${label}`).openPopup();
      } else {
        crowdMarker = L.marker(coords)
          .addTo(map)
          .bindPopup(`üë• Crowd: ${label}`)
          .openPopup();
      }
    };

    // Function to display POIs on the map
    window.displayPOIs = function(pois) {
      if (!map || !Array.isArray(pois)) return;
      
      console.log("üè¢ Displaying", pois.length, "POIs on map");
      
      // Clear existing POI markers
      poiMarkers.forEach(marker => map.removeLayer(marker));
      poiMarkers = [];
      poiData = pois;

      pois.forEach(poi => {
        if (!poi.centroid || !poi.centroid.latitude || !poi.centroid.longitude) {
          console.warn("‚ö†Ô∏è POI missing coordinates:", poi);
          return;
        }

        const coords = [poi.centroid.latitude, poi.centroid.longitude];
        
        // Create custom icon for POI
        const poiIcon = L.divIcon({
          className: 'poi-marker',
          html: '',
          iconSize: [12, 12],
          iconAnchor: [6, 6]
        });

        // Create marker
        const marker = L.marker(coords, { icon: poiIcon })
          .addTo(map)
          .bindPopup(`
            <div style="text-align: center;">
              <strong>üè¢ ${poi.name || 'Unnamed Building'}</strong><br>
              <button onclick="selectPOI('${poi.id}')" style="
                margin-top: 8px;
                padding: 6px 12px;
                background-color: #007bff;
                color: white;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 12px;
              ">Navigate Here</button>
            </div>
          `);

        // Add label that shows on hover or zoom
        if (map.getZoom() >= 16) {
          const label = L.marker(coords, {
            icon: L.divIcon({
              className: 'poi-label',
              html: poi.name || 'Building',
              iconSize: [null, null],
              iconAnchor: [0, 0]
            })
          }).addTo(map);
          
          poiMarkers.push(label);
        }

        poiMarkers.push(marker);
      });

      // Show/hide labels based on zoom level
      map.on('zoomend', function() {
        const zoom = map.getZoom();
        poiMarkers.forEach(marker => {
          if (marker.options.icon && marker.options.icon.options.className === 'poi-label') {
            if (zoom >= 16) {
              marker.addTo(map);
            } else {
              map.removeLayer(marker);
            }
          }
        });
      });
    };

    // Function to handle POI selection from map
    window.selectPOI = function(poiId) {
      const poi = poiData.find(p => p.id === poiId);
      if (poi && window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'POI_SELECTED',
          poi: poi
        }));
      }
    };

    // Start the map
    try {
      initMap();
    } catch (e) {
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({
          type: 'ERROR',
          message: e.message,
          stack: e.stack
        }));
      }
    }

    // Function to clear the destination marker and end circle
    window.clearDestinationMarker = function() {
      if (destinationMarker) {
        map.removeLayer(destinationMarker);
        destinationMarker = null;
      }
      if (endCircle) {
        map.removeLayer(endCircle);
        endCircle = null;
      }
    };

    
    window.drawRoute = function(coords) {
      if (!map || !Array.isArray(coords)) return;
    
      // Remove existing route if already present
      if (window.routeLayer) {
        map.removeLayer(window.routeLayer);
        window.routeLayer = null;
      }
    
      // Remove previous destination marker
      if (destinationMarker) {
        map.removeLayer(destinationMarker);
        destinationMarker = null;
      }
    
      // Remove previous end circle
      if (endCircle) {
        map.removeLayer(endCircle);
        endCircle = null;
      }
    
      // Remove previous start circle
      if (startCircle) {
        map.removeLayer(startCircle);
        startCircle = null;
      }
    
      const latlngs = coords.map(([lon, lat]) => [lat, lon]);
    
      window.routeLayer = L.polyline(latlngs, {
        color: 'blue',
        weight: 6,
        opacity: 1,
        dashArray: '8,6',
      }).addTo(map);
    
      // Add start circle and keep reference
      startCircle = L.circle(latlngs[0], { radius: 5, color: 'green' }).addTo(map);
    
      // Add end circle and keep reference
      endCircle = L.circle(latlngs[latlngs.length - 1], { radius: 5, color: 'red' }).addTo(map);
    
      const bounds = window.routeLayer.getBounds();
      map.fitBounds(bounds.pad(0.3));
    
      // Add start marker
      L.marker(latlngs[0]).addTo(map).bindPopup("üö© Start").openPopup();
    
      // Add end marker and keep reference
      destinationMarker = L.marker(latlngs[latlngs.length - 1]).addTo(map).bindPopup("üèÅ End");
    };
    
    // ...existing code...

        // Update route progress
    window.updateRouteProgress = function(pointIndex) {
      if (!route) return;
      
      // Highlight the current segment of the route
      const routeSegment = route.getLatLngs().slice(0, pointIndex + 1);
      
      if (!progressLine) {
        progressLine = L.polyline(routeSegment, {
          color: '#00ff00',
          weight: 6,
          opacity: 0.8
        }).addTo(map);
      } else {
        progressLine.setLatLngs(routeSegment);
      }
    };
    
    // Update the route with new coordinates
    window.updateRoute = function(coordinates) {
      if (route) {
        map.removeLayer(route);
      }
      
      if (progressLine) {
        map.removeLayer(progressLine);
        progressLine = null;
      }
      
      // Add this to your map HTML file
      window.updateUserLocation = function(lat, lng) {
        // Remove previous marker if it exists
        if (userMarker) {
          map.removeLayer(userMarker);
        }
        
        // Create a new marker at the exact coordinates
        const userLatLng = L.latLng(lat, lng);
        userMarker = L.marker(userLatLng, {
          icon: userIcon,
          zIndexOffset: 1000 // Ensure user marker is on top
        }).addTo(map);
        
        // Center map on user if not in navigation mode
        if (!window.isNavigating) {
          map.setView(userLatLng, map.getZoom());
        }
        
        // Store these coordinates for later use
        window.userCoordinates = {lat, lng};
      };
      
      window.drawRoute = function(coordinates) {
        // Clear any existing route
        if (route) {
          map.removeLayer(route);
        }
        
        if (progressLine) {
          map.removeLayer(progressLine);
          progressLine = null;
        }
        
        // Convert route coordinates to LatLng objects
        const routeLatLngs = coordinates.map(coord => L.latLng(coord[1], coord[0]));
        
        // Ensure the first point of the route is exactly at the user's position
        if (window.userCoordinates && routeLatLngs.length > 0) {
          // Replace the first point with the user's exact position
          routeLatLngs[0] = L.latLng(window.userCoordinates.lat, window.userCoordinates.lng);
        }
        
        // Create the route polyline
        route = L.polyline(routeLatLngs, {
          color: '#3388ff',
          weight: 6,
          opacity: 0.8
        }).addTo(map);
        
        // Fit the map to show the whole route
        map.fitBounds(route.getBounds(), { padding: [50, 50] });
        
        // Set navigation mode
        window.isNavigating = true;
      };
    
    // Clear the route
    window.clearRoute = function() {
      if (route) {
        map.removeLayer(route);
        route = null;
      }
      
      if (progressLine) {
        map.removeLayer(progressLine);
        progressLine = null;
      }
    };

    

  </script>
</body>
</html>